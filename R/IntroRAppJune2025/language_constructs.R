# ==============================================================================
# Language Constructs Demonstrations
# ==============================================================================

demonstrate_control_structures <- function() {
  output <- paste(
    "# Control Structures in R",
    "",
    "# === IF-ELSE Statements ===",
    "x <- 10",
    "if (x > 5) {",
    "  print('x is greater than 5')",
    "} else if (x == 5) {",
    "  print('x equals 5')",
    "} else {",
    "  print('x is less than 5')",
    "}",
    "",
    "# Vectorized ifelse",
    "numbers <- c(1, 5, 10, 15)",
    "result <- ifelse(numbers > 7, 'High', 'Low')",
    "# Result: 'Low' 'Low' 'High' 'High'",
    "",
    "# === SWITCH Statement ===",
    "grade <- 'B'",
    "message <- switch(grade,",
    "  'A' = 'Excellent!',",
    "  'B' = 'Good job!',",
    "  'C' = 'Average',",
    "  'D' = 'Below average',",
    "  'F' = 'Failed',",
    "  'Invalid grade'",
    ")",
    "",
    "# === FOR Loops ===",
    "# Traditional for loop",
    "for (i in 1:5) {",
    "  print(paste('Iteration:', i))",
    "}",
    "",
    "# Loop over vectors",
    "fruits <- c('apple', 'banana', 'cherry')",
    "for (fruit in fruits) {",
    "  print(paste('I like', fruit))",
    "}",
    "",
    "# === WHILE Loops ===",
    "counter <- 1",
    "while (counter <= 3) {",
    "  print(paste('Counter:', counter))",
    "  counter <- counter + 1",
    "}",
    "",
    "# === REPEAT Loops ===",
    "i <- 1",
    "repeat {",
    "  print(i)",
    "  i <- i + 1",
    "  if (i > 3) break",
    "}",
    "",
    "# === NEXT and BREAK ===",
    "for (i in 1:10) {",
    "  if (i %% 2 == 0) next  # Skip even numbers",
    "  if (i > 7) break       # Stop after 7",
    "  print(i)  # Prints: 1, 3, 5, 7",
    "}",
    sep = "\n"
  )
  return(output)
}

demonstrate_functions <- function() {
  output <- paste(
    "# Functions in R",
    "",
    "# === Basic Function ===",
    "greet <- function(name) {",
    "  paste('Hello,', name, '!')",
    "}",
    "greet('Alice')  # 'Hello, Alice !'",
    "",
    "# === Function with Default Arguments ===",
    "calculate_bmi <- function(weight, height, unit = 'metric') {",
    "  if (unit == 'metric') {",
    "    bmi <- weight / (height^2)",
    "  } else {",
    "    bmi <- (weight / (height^2)) * 703",
    "  }",
    "  return(round(bmi, 2))",
    "}",
    "",
    "calculate_bmi(70, 1.75)           # 22.86",
    "calculate_bmi(154, 69, 'imperial') # 22.74",
    "",
    "# === Function with Multiple Returns ===",
    "stats_summary <- function(x) {",
    "  list(",
    "    mean = mean(x),",
    "    median = median(x),",
    "    sd = sd(x),",
    "    min = min(x),",
    "    max = max(x)",
    "  )",
    "}",
    "",
    "result <- stats_summary(c(1, 2, 3, 4, 5))",
    "",
    "# === Anonymous Functions (Lambdas) ===",
    "numbers <- c(1, 2, 3, 4, 5)",
    "squared <- sapply(numbers, function(x) x^2)",
    "",
    "# Using purrr for functional programming",
    "library(purrr)",
    "cubed <- map_dbl(numbers, ~ .x^3)",
    "",
    "# === Higher-Order Functions ===",
    "apply_operation <- function(x, y, operation) {",
    "  operation(x, y)",
    "}",
    "",
    "add <- function(a, b) a + b",
    "multiply <- function(a, b) a * b",
    "",
    "apply_operation(5, 3, add)      # 8",
    "apply_operation(5, 3, multiply) # 15",
    "",
    "# === Closures ===",
    "create_counter <- function() {",
    "  count <- 0",
    "  function() {",
    "    count <<- count + 1",
    "    count",
    "  }",
    "}",
    "",
    "counter1 <- create_counter()",
    "counter2 <- create_counter()",
    "counter1()  # 1",
    "counter1()  # 2", 
    "counter2()  # 1",
    "",
    "# === Recursive Functions ===",
    "factorial <- function(n) {",
    "  if (n <= 1) {",
    "    return(1)",
    "  } else {",
    "    return(n * factorial(n - 1))",
    "  }",
    "}",
    "",
    "factorial(5)  # 120",
    sep = "\n"
  )
  return(output)
}

demonstrate_loops_apply <- function() {
  output <- paste(
    "# Loops vs Apply Family Functions",
    "",
    "# === Apply Family ===",
    "# apply() - for matrices/arrays",
    "mat <- matrix(1:12, nrow = 3)",
    "row_sums <- apply(mat, 1, sum)    # Sum by rows",
    "col_means <- apply(mat, 2, mean)  # Mean by columns",
    "",
    "# lapply() - returns list",
    "numbers <- list(a = 1:3, b = 4:6, c = 7:9)",
    "sums <- lapply(numbers, sum)",
    "# Result: list(a = 6, b = 15, c = 24)",
    "",
    "# sapply() - simplified lapply",
    "sums_vector <- sapply(numbers, sum)",
    "# Result: named vector c(a = 6, b = 15, c = 24)",
    "",
    "# mapply() - multivariate apply",
    "mapply(rep, 1:4, 4:1)",
    "# Repeats 1 four times, 2 three times, etc.",
    "",
    "# === Comparison: Loop vs Apply ===",
    "# Using for loop",
    "data <- list(c(1,2,3), c(4,5,6), c(7,8,9))",
    "means_loop <- numeric(length(data))",
    "for (i in seq_along(data)) {",
    "  means_loop[i] <- mean(data[[i]])",
    "}",
    "",
    "# Using apply family",
    "means_apply <- sapply(data, mean)",
    "",
    "# === purrr Functions (Modern Approach) ===",
    "library(purrr)",
    "",
    "# map() family - type-safe alternatives",
    "numbers <- list(1:3, 4:6, 7:9)",
    "means_map <- map_dbl(numbers, mean)  # Returns double",
    "chars_map <- map_chr(numbers, ~ paste(.x, collapse = ','))",
    "",
    "# map2() - iterate over two lists",
    "x <- list(1, 10, 100)",
    "y <- list(1, 2, 3)",
    "result <- map2_dbl(x, y, ~ .x + .y)  # c(2, 12, 103)",
    "",
    "# pmap() - iterate over multiple lists",
    "args <- list(",
    "  mean = c(0, 10, 20),",
    "  sd = c(1, 2, 3),",
    "  n = c(5, 10, 15)",
    ")",
    "samples <- pmap(args, ~ rnorm(.z, .x, .y))",
    "",
    "# === Performance Comparison ===",
    "# For large datasets, consider:",
    "# 1. Vectorized operations (fastest)",
    "# 2. apply family (good)",
    "# 3. for loops (slowest in R)",
    "",
    "# Vectorized (preferred)",
    "x <- 1:1000000",
    "result1 <- x^2  # Very fast",
    "",
    "# Using sapply",
    "result2 <- sapply(x, function(i) i^2)  # Slower",
    "",
    "# Using for loop",
    "result3 <- numeric(length(x))",
    "for (i in seq_along(x)) {",
    "  result3[i] <- x[i]^2  # Slowest",
    "}",
    sep = "\n"
  )
  return(output)
}

demonstrate_error_handling <- function() {
  output <- paste(
    "# Error Handling in R",
    "",
    "# === try() Function ===",
    "# Prevents script from stopping on error",
    "result <- try({",
    "  x <- 1 / 0  # This would normally cause an error",
    "  print('This won't print')",
    "}, silent = TRUE)",
    "",
    "if (inherits(result, 'try-error')) {",
    "  print('An error occurred!')",
    "}",
    "",
    "# === tryCatch() Function ===",
    "# More sophisticated error handling",
    "safe_divide <- function(a, b) {",
    "  tryCatch({",
    "    if (b == 0) {",
    "      stop('Division by zero is not allowed')",
    "    }",
    "    return(a / b)",
    "  },",
    "  error = function(e) {",
    "    message('Error: ', e$message)",
    "    return(NA)",
    "  },",
    "  warning = function(w) {",
    "    message('Warning: ', w$message)",
    "    return(a / b)",
    "  },",
    "  finally = {",
    "    message('Division operation completed')",
    "  })",
    "}",
    "",
    "safe_divide(10, 2)  # Returns 5",
    "safe_divide(10, 0)  # Returns NA with error message",
    "",
    "# === Custom Error Messages ===",
    "validate_input <- function(x) {",
    "  if (!is.numeric(x)) {",
    "    stop('Input must be numeric', call. = FALSE)",
    "  }",
    "  if (any(is.na(x))) {",
    "    warning('Input contains NA values')",
    "  }",
    "  if (length(x) == 0) {",
    "    stop('Input cannot be empty', call. = FALSE)",
    "  }",
    "  return(TRUE)",
    "}",
    "",
    "# === Assertions ===",
    "# Using stopifnot() for quick assertions",
    "calculate_mean <- function(x) {",
    "  stopifnot(",
    "    is.numeric(x),",
    "    length(x) > 0,",
    "    !all(is.na(x))",
    "  )",
    "  mean(x, na.rm = TRUE)",
    "}",
    "",
    "# === Graceful Degradation ===",
    "robust_analysis <- function(data) {",
    "  results <- list()",
    "  ",
    "  # Try to calculate mean",
    "  results$mean <- tryCatch({",
    "    mean(data, na.rm = TRUE)",
    "  }, error = function(e) NA)",
    "  ",
    "  # Try to calculate median",
    "  results$median <- tryCatch({",
    "    median(data, na.rm = TRUE)",
    "  }, error = function(e) NA)",
    "  ",
    "  # Try to calculate standard deviation",
    "  results$sd <- tryCatch({",
    "    sd(data, na.rm = TRUE)",
    "  }, error = function(e) NA)",
    "  ",
    "  return(results)",
    "}",
    "",
    "# === Debugging Tools ===",
    "# browser() - interactive debugging",
    "debug_function <- function(x) {",
    "  y <- x * 2",
    "  # browser()  # Uncomment to enter debug mode",
    "  z <- y + 1",
    "  return(z)",
    "}",
    "",
    "# traceback() - see call stack after error",
    "# debug() and undebug() - debug specific functions",
    "# options(error = recover) - interactive error recovery",
    sep = "\n"
  )
  return(output)
}
